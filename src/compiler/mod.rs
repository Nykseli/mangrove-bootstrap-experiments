use crate::ast::ASTFunction;

#[derive(Debug, Clone)]
pub struct GlobalData {
	start: i32,
	data: String,
}

#[derive(Debug)]
pub struct Compiler {
	ast: Vec<ASTFunction>,
	global_data: Vec<GlobalData>,
}

impl Compiler {
	pub fn new(ast: Vec<ASTFunction>) -> Self {
		Self {
			ast,
			global_data: Vec::new(),
		}
	}

	/// Add data and return the created item
	fn add_data(global_data: &mut Vec<GlobalData>, data: &str) -> GlobalData {
		// first 4096 bytes are reserved for internal functions
		let start = if global_data.len() == 0 {
			4096
		} else {
			let last = global_data.last().unwrap();
			last.start + last.data.len() as i32
		};

		// TODO: properly replace literals
		let data: String = data.replace("\n", "\\n");
		let new_data = GlobalData { start, data };

		global_data.push(new_data.clone());
		new_data
	}

	pub fn compile(&mut self) -> String {
		let mut functions = String::new();
		let mut global_data: Vec<GlobalData> = Vec::new();

		for function in &self.ast {
			functions.push_str(&format!("(func ${}\n", function.name));
			for call in &function.body.statements {
				let data = Self::add_data(&mut global_data, &call.arg);
				functions.push_str(&format!(
					"(call ${} (i32.const {}) (i32.const {}))\n",
					call.name,
					data.start,
					data.data.len()
				));
			}

			functions.push(')');
		}

		let data: Vec<String> = global_data
			.iter()
			.map(|gd| format!("(data (i32.const {}) \"{}\")", gd.start, gd.data))
			.collect();
		let data = data.join("\n");

		format!(
			";; Autogenerated module, do not modify

		(module
			;; Internal functions
			;; TODO: only import required ones
			(import \"internals\" \"__print_str\" (func $__print_str (param i32) (param i32)))
			;; shared internal memory
			(import \"internals\" \"memory\" (memory 0))

			;; Generated memory
			{}

			;; generated functions
			{}

			;; We always have to export main
			(export \"main\" (func $main))
		)
			",
			data, functions
		)
	}
}
